#网络
参考书籍：《图解TCP/IP》，《TCP/IP详解 卷一》，《图解HTTP》，《HTTP权威指南》
##OSI网络模型以及各层协议
###七层模型
  物理层
    负责位从一个节点到另一个节点的传输
  数据链路层
    数据格式为帧，传输之间地址为物理地址
  网络层
    数据格式为分组，传输之间地址为IP地址
  传输层
    数据格式为报文，传输之间地址为端口地址
  会话层
    负责对话控制和同步
  表示层
    负责翻译、加密和压缩数据
  应用层
    负责向用户提供服务器
###集线器、交换机和路由器的区别
集线器和交换机区别
1. 集线器工作在物理层，交换机工作在数据链路层
2. 集线器传输速度没有交换机快
3. 集线器的数据传输方式是广播方式，而交换机的传输是有目的的，只在目的的MAC找不到的情况下会使用广播

交换机和路由器区别
1. 交换机工作在数据链路层、路由器工作在网络层
2. 交换机根据MAC地质寻址、路由器根据IP地址寻址
3. 转发速度不同：交换机转发速度快，路由器相对较慢

###网桥、网卡、网关
网桥：一个局域网与另一个局域网之间建立连接的桥梁、工作在数据链路层上
网关：实质上是一个网络通向其他网络的IP地址、工作在应用层和传输层
网卡：
  将电脑的数据封装为帧，通过网线(或者在无线网络情况下是电磁波)将数据发送到网路上去。
  接收网络上其他设备传过来的帧，并将帧重新组合成数据，发送到所在的电脑中。
###静态路由和动态路由
  静态是由管理员手工配置的，适合比较简单的网络或需要做路由特殊控制。
  而动态则是由动态路由协议自动维护的，不需要人工干预，适合比较复杂大型的网络
##TCP & UDP & IP ... 各个协议
###IP地址A、B、C类
###TCP与UDP之间的区别 
* TCP是面向连接，UDP是无连接的，
  面向连接就是TCP在传输前先发送连接请求和应答包，确定双方能够正常传输后，才传输。
  而UDP基于无连接，发送之前不考虑不能保证数据一定送到
* TCP能保证可靠传输，UDP不能。
* TCP结构较复杂，UDP结构简单，消耗资源少，建立过程较快。
* TCP面向字节流的，UDP是面向报文的
* TCP连接是点到点，UDP则可以n对n。所以广播和多播只能用UDP
* TCP有确认、重传、拥塞控制机制。UDP在没有建立连接或者对方已经退出的情况中仍然会发送数据
* TCP头部(20字节)比UDP头部(8字节)大

**为什么TCP是可靠的？如何保证可靠性**
   对于可靠性，TCP通过以下方式进行保证:
   * 数据包校验
    如果校验出包有错，就会丢弃报文段并且不给响应。这样发送端数据超时后会重发数据。
   * 对失序数据包重排序
    TCP会对失序数据进行重新排序，然后才交给应用层。
   * 丢弃重复数据
    TCP能够丢弃重复数据
   * 应答机制
    当TCP收到包的时候会回发一个确认段，确认自己收到了
   * 超时重发
    当TCP发出一个段时候，会启动一个定时器，等待目的端确认收到，如果超时就会重发报文段
   * 流量控制
    TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许接收接收端缓冲区所能够接纳的数据。

###TTL概念
###TCP和UDP分别对应协议(应用层)
TCP: STMP, TELNET, HTTP, FTP
UDP: DNS,TFTP,RIP,DHCP,SNMP
###TCP和UDP应用场景    
TCP:对效率要求低，对准确性要求较高 (如文件传输、重要状态的更新等)
UDP:对效率要求高，对准确性要求较低 (如视频传输、实时通信等)。
TCP: SMTP、TELNET、HTTP、FTP
UDP: RIP、DNS、BOOTP、DHCP、SNMP、NFS
###IP首部，TCP首部，UDP首部 
IP首部 20字节
TCP首部 20字节，如果有选项可以到60字节
UDP首部 8字节
###如何实现可靠的UDP
  在UDP上实现一个TCP协议是没有意义的
  一般就实现个确认 + 重传，为每一个发送的包分配一个包id，当一端接收到包后需要发送回ack确认包id
  然后时间到了没有ack就重发
  
  
###TCP三次握手与四次挥手,详细说明TCP状态迁移过程 
三次握手
1. 客户端发送SYN=1，SEQ=X的帧发送给Server，客户端进入SYN_SENT状态等待服务器确认
2. 服务器收到SYN帧，发送一个SYN=1,ACK=1,ack=J+1,SEQ=K的帧给客户端确认连接请求，服务器进入SYN_RCVD状态
3. 客户端收到SYN+ACK后，发回K=1,ack=K+1，此时服务器检查该帧，确认则连接建立成功，服务器和客户端进入Established状态可以开始传输数据。

四次挥手
1. 客户端发送FIN到服务器，关闭客户端到服务器的数据传送，客户端进入FIN_WAIT1状态。
2. 服务器收到FIN，发回一个ACK，服务器进入CLOSE_WAIT状态。此时客户端仍可接收来自服务器的数据
3. 客户端接收到ACK帧后进入FIN_WAIT2状态
3. 服务器发送FIN，关闭服务器到客户端的数据传送。服务器进入LAST_ACK状态。
4. 客户端收到FIN帧后，发回一个ACK帧，客户端进入TIME_WAIT状态等待2MSL后进入CLOSED状态，服务器进入CLOSED状态

扩展:
**2MSL是什么状态？为什么TIME_WAIT状态需要等2MSL后进入CLOSED状态?**
2MSL是最大文段生存时间
假如网络不太好服务器没收到最后的ACK帧则会重发FIN帧，所以要先等待，用于重发可能丢失的ACK报文。


**三次握手为什么不是两次或者四次？为什么是四次挥手**
三次握手：
四次的次数太多没有必要。
不是两次是为了防止已失效的链接请求报文突然又传送到了服务端，因而产生错误。
如果采用两次的话，当服务器发出确认帧的时候链接就建立了。
假设A发出的连接请求段（SYN+ACK）不是丢失而是长时间滞留，延迟后才到达B，这时B如果收到，就会同意建立连接，等待A发送资源，这样就会浪费资源。
四次挥手：
因为TCP是全双工的，一端停止发送数据后仍可以接收数据。有时候可能服务器需要时间处理数据不能立即发送响应数据回来。
**TCP三次握手的缺陷**
  客户端不断进行请求连接的时候，服务器端会为每一个请求创建一个连接，并向其发送确认报文，然后等待客户端进行确认。
  DDos攻击：
    利用大量的合理的服务请求占用过多的服务资源，使合法用户没法得到服务的响应。
    SYN-Flood或叫SYN泛洪攻击就是攻击的一种。
  SYN-Flood攻击: 
    通过向网络服务所在端口发送大量的伪造源地址的攻击报文，就可能造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户进行访问。
  防范:
    无效连接监视释放 
      这种方法不停的监视系统中半开连接和不活动连接，当达到一定阈值时拆除这些连接，释放系统资源。这种绝对公平的方法往往也会将正常的连接的请求也会被释放掉，”伤敌一千，自损八百“
    使用SYN 2Proxy防火墙

###TCP相关技术
###TCP重发机制，Nagle算法
###TCP的拥塞控制使用的算法和具体过程
TCP处理拥塞的一般策略基于三个阶段：慢速启动、拥塞避免、拥塞检测
* 慢速启动
   从小到大逐渐调整拥塞窗口大小。用很慢的传输速率启动，但迅速的增加到阈值。
   指数增长：
    开始的时候设置窗口大小为1MSS，每次接收到窗口中的一个段的确认之后，窗口大小就增加一个MSS值。
    按指数规律增加直到阈值
* 拥塞避免
   为了避免拥塞，而减少增加的速率
   加性增加：
    当拥塞窗口达到阈值后，指数增加停止，开始加性增加，每次整个窗口所有段的确认之后，窗口大小才增加1MSS。
    如此增加直到检测到拥塞
* 拥塞检测：
    发送方推测发生拥塞的唯一方法时从重传的要求，但是重传的情况有两种:快重传或者重传计时器到时
    **快重传**
      快重传要求接收方在收到一个失序的报文段后就立即发出重复确认而不要等到自己发送数据报的时候捎带确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必等待等待设置重传计时器时间到期
    在快重传(接收到三个ACK)的情况下，TCP会设置阈值为当前拥塞窗口的一半，将cwnd设置为阈值，开始拥塞避免状态
    在计时器到时的情况下，会设置阈值为当前拥塞窗口大小的一般，设置cwnd为1MSS，启动慢速启动状态

###TCP的流量控制
TCP采用滑动窗口实现流量控制。
窗口大小 = min(cwnd,rwnd)，rwnd是拥塞窗口、cwnd是接收窗口，接受窗口值是在另一端的确认段中宣布的值。拥塞窗口的值由拥塞控制机制确定
###ARP的机制，RARP的实现
ARP工作原理:
每个主机都会在ARP缓冲区建立一个ARP列表，表示IP和MAC的映射关系
当主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的地址，
如果有则直接发送，如果没有，向本网段的所有主机发送ARP包，包含源地址IP地址、源主机MAC地址、目的主机IP地址
所有主机接收到后检查自己的IP地址是不是目的地址，如果是返回自己的MAC地址。
源主机接收到响应，将目的主机的IP和MAC地址写入ARP列表，并向目的主机发送消息。
###Ping和TraceRoute实现原理
###ICMP协议
ICMP是因特网控制保温协议(Internet Control Message Protocol)
用于补充IP协议所缺失的差错控制和为朱姐和管理查询的机制
###地址栏输入一个url到最后内容出现在页面上，中间经历了哪些过程
  1. 浏览器查询DNS，获取域名对应的IP地址。
    具体过程包括
      查询浏览器缓存，
      读取本地的Host文件
      路由缓存
      并对DNS服务器(本地域名、顶级域名、根域名)进行查询等。
    如果本地查不到，可以从名字服务器中请求递归应答。也可以请求迭代应答等从其他服务器查询。
  2. 浏览器获得IP地址以后，向对应的服务器发起三次握手，请求连接
  3. 服务器接收到请求，并根据路径映射到特点的请求处理器进行处理，并将处理结果和响应的视图返回给浏览器
  4. 浏览器解析并渲染视图，如果遇到对JS、CSS、图片等静态资源的引用，则重复上述步骤向服务器请求这些资源
  5. 浏览器根据请求到的资源、数据渲染页面最终对用户显示一个完整的页面

##http相关
###长连接、短连接
  短连接：
    每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接
  长连接：
    网页打开完成后，客户端和服务器之间的TCP连接不会关闭，后续客户端再次访问的时候会继续使用这个连接。
    可以通过设置keep-alive属性设置保持的时间
###Session、Cookie、Application概念、对比
Cookie用于记录用户状态，是计算机存储在浏览器目录的文本文件。
Session是会话，指从一个浏览器窗口打开到关闭这个期间。如果说Cookie是在客户端保持状态的话，Session就是在服务器端保持状态的方案。
不过Session常常需要借助于Cookie或URL重写机制来达到保存标识的目的
两者对比:
* Cookie存在安全隐患，而Session存在服务器端，相对更加安全
* Cookie有大小限制，而Session相对来说没有，理论上只与服务器的内存大小有关。
* Session是保存在服务器上存在一段时间才会消失，如果session过多会增加服务器的压力。

###http/https 1.0、1.1、2.0的特点和区别
  https://www.jianshu.com/p/52d86558ca57
  1.0 规定浏览器只与服务器保持短暂的连接，每次请求都需要与服务器建立一个tcp连接，完成后就断开
         由于连一次就断，所以效率很低，每次请求都经历慢启动和三次握手
  1.1 支持持久连接，在一个TCP连接中可以传输多个HTTP请求和响应。性能优化PC端很明显，但是移动端一般。因为请求分散
  2.0 完全的多路复用，只需要一个连接可实现并行。
      采用二进制格式而非文本格式，二进制分帧: 在应用层和传输层中添加一个二进制分帧层，改进传输性能
###get/post 区别
  1. 功能上讲：get重点从服务器上获取资源，post重点是更新服务器上的数据
  2. 从请求参数形式上看：get传输数据是通过url请求，以field = value的方式，放在?后，post传输参数则是放在request体中进行传输
  3. 从安全性上看：get是不安全的，因为url是可见的，容易泄漏
  4. 从请求大小看：get传输数量小受url长度限制但效率较高，post可以传输大量数据
  5. 从REST服务角度上看，GET是幂等的，即读取同一个资源总是得到相同的响应，而POST不是幂等的

###怎么理解HTTP的？
  https://www.zhihu.com/question/53226983
###http的启动方法，没答出来
###HTTP返回状态码
  1xx指示信息-表示请求已接收、继续处理
  2xx成功-表示请求已被成功接收、理解、接收
    200 正常处理
    204 受理了请求但是没有资源
    206 客户端只请求了一部分，服务器只对部分资源执行资源方法
  3xx重定向
    301 永久性重定向
    302 临时重定向
    303 与302类似，但是希望客户端通过GET方法重定向
    304 发送附带条件的请求时，条件不满足时返回
    307 临时重定向，与302类似，但是强制要求POST方法
  4xx客户端错误—请求有语法错误或者请求无法实现
    400 请求语法有错误，服务器无法识别
    401 请求需要认证
    403 Forbidden 资源不可用，权限不够无法访问
    404 无法找到指定位置的资源 
  5xx服务端错误
    500 服务器内部错误
    503 服务器正忙
###http 协议头相关
http数据由请求行，首部字段，空行，报文主体四个部分组成 
首部字段分为：通用首部字段，请求首部字段，响应首部字段，实体首部字段

###https与http的区别？如何实现加密传输？加解密方式？
  HTTPS需要用到CA申请证书
  https在传输数据前需要客户端和服务器之间先握手，确认双方加密传输数据的密码信息。
  HTTP的连接是简单的，无状态的，而HTTPS是HTTP+SSL构建的可以进行加密传输、身份认证的网络协议，比HTTP协议安全
  使用的TLS/SSL协议
  **TLS/SSL**
  非对称加密 + 对称加密 + 散列算法



#数据库
主要参考书籍：《数据库系统概念》，《高性能MySQL》
##SQL语言(内外连接，子查询，分组，聚集，嵌套，逻辑)
##MySQL索引方法？索引的优化？
##InnoDB与MyISAM区别？
##事务的ACID
##事务的四个隔离级别
##查询优化(从索引上优化，从SQL语言上优化)
##B-与B+树区别？
##MySQL的联合索引(又称多列索引)是什么？生效的条件？
##分库分表

#操作系统
主要参考书籍：《现代操作系统》，《APUE》，《UNP》，《LINUX内核设计与实现》，《深入理解LINUX内核》
###文件系统管理的最小磁盘空间单位
是簇
###进程间通信方式
管道、消息队列、信号量、共享内存、SOCKET
管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams
管道是半双工的，速度慢
消息队列：存放在内核中，容量受系统限制。一个消息队列有一个标识符。是面向记录的。消息队列可以实现信息的随机查询。
信号量用于进程间互斥与同步
共享内存：
最快的一种IPC，因为进程直接对内存操作，因为多个进程可以同时操作，所以需要同步，通常和信号量结合一起使用。
**匿名管道与命名管道的区别**
  匿名管道只能在具有公共祖先的两个进程间使用。
**共享文件映射mmap **
  mmap建立进程空间到文件的映射，在建立的时候并不直接将文件拷贝到物理内存，同样采用缺页终端。mmap映射一个具体的文件可以实现任意进程间共享内存，映射一个匿名文件，可以实现父子进程间共享内存。
**常见的信号有哪些**
SIGINT，SIGKILL(不能被捕获)，SIGTERM(可以被捕获)，SIGSEGV，SIGCHLD，SIGALRM
###进程与线程区别?线程比进程具有哪些优势？ 
  进程是程序的一个执行、是**资源调度的基本单位**，拥有独立的地址空间，而同一进程中的线程共享该进程的地址空间。
  线程是进程的实体，是**CPU调度和分派的基本单位**。它是比进程更小的能独立运行的基本单位。
  线程的优势在于线程间通信比较方便，因为共享数据。
###进程同步的方式
  信号量、消息传递(send、receive)
  管程：是由一个或多个过程、一个初始化序列和局部数据组成的软件模块，其主要特点如下：
    任何时候管程中只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。
  
###线程同步的方式
  事件：允许线程在处理完一个任务后，主动唤醒另外一个线程执行任务
  临界区：当多个线程访问独占的共享资源时，使用临界区对象
  互斥量：互斥对象和临界区对象非常相似，只是还允许在进程间使用，相比临界区更消耗资源。
  信号量
###什么时候用多进程？什么时候用多线程？ 
  多进程，一个进程崩溃不会影响其他的进程，但是进程的切换和通信比较麻烦
  多线程，数据共享和通信比较方便，但是一个线程死亡的话，其他线程也崩溃了
  所以如果需要频繁交互的，频繁对同一个对象进行不同的处理，选择多线程合适
### 什么是缓冲区溢出?有什么危害，其原因是什么?
缓冲区溢出是指计算向缓冲区填充的数据超出了缓冲区本身的容量，溢出的数据覆盖了合法数据。
危害有：程序崩溃、跳转执行恶意代码
主要原因是程序中没有仔细检查用户输入。
## LINUX中进程和线程使用的几个函数？ 




##虚拟内存的作用？实现？
##操作系统层面对内存的管理？
##内存池的作用？STL里内存池如何实现？
##进程空间和内核空间对内存的管理不同？
##Linux的slab层，VAM？
###伙伴算法
##高端内存
##进程调度
##Linux进程分为两种，实时进程和非实时进程；
##优先级分为静态优先级和动态优先级，优先级的范围；
###进程调度策略
FCFS先来先服务
SJF短作业优先
FPF最高优先权优先：又分为非抢占式和抢占式，区别是进程一旦运行后遇到另一个优先级更高的线程调度程序会不会停止当前进程
高响应比算法：
RP = (等待时间+运行时间)/运行时间
时间片轮转法：
早起的时间片轮转算法：系统将所有的进程按FCFS原则排成一个就绪队列，每次调度的时候把CPU分配给队首进程，并令其执行时间片。时间片的大小从几ms到几百ms，执行完毕后，停止进程执行并送往就绪队列的末尾然后调度队首继续上述步骤。这样保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。
多级反馈队列调度算法：
设置多个就绪队列，并为各个队列赋予不同的优先级，从1-n队列优先级逐个降低，该算法赋予各个进程中执行时间片的大小也各不相同，优先级越高的队列中，时间片就越小。
每当一个新进程进入内存后，就把它放入第一队列的末尾，按照FCFS原则排队等待调度，一个时间片执行完毕后如果未完成就放入第二队列的末尾，同样按照FCFS原则调度。如此下去直到n个队列。
仅当第一队列空闲的时候调度程序才调度第二队列中的进程运行，仅当第1~(i-1)的队列均空时，才会调度第i队列中的进程运行，如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列，则此时新进程将抢占正在运行进程的处理机。
##交互进程通过平均睡眠时间而被奖励；
###死锁，产生的条件，死锁的避免；
  死锁:在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。
  产生的条件:
  资源互斥使用：进程对其申请的资源进行排他控制，其他进程申请该资源只能等待。
  非剥夺控制：占有资源的进程只能自己释放资源，其他进程不能抢
  零散请求与控制：进程可以按需求逐次请求，而不是一次要求全部资源才能执行。
  循环等待：等待资源的进程形成一个链，链上的进程都在等待下一个进程占有的资源，造成了死循环。
#Linux命令行
##Linux命令 在一个文件中，倒序打印第二行前100个大写字母
  cat filename | head -n 2 | tail -n 1 | grep '[[:upper:]]' -o | tr -d '\n'| cut -c 1-100 | rev 
##与CPU，内存，磁盘相关的命令(top，free, df, fdisk)
  top:查看各进程资源占用情况          
  free：内存使用情况
  df:大 
  网络相关的命令netstat，tcpdump等      
  netstat: 网络状况
  tcpdump
  sed, awk, grep三个超强大的命名，分别用与格式化修改，统计，和正则查找
  sed十个编辑器、grep以行查找、awk更强增加分隔符
  grep更适合单纯查找后匹配、sed适合编辑、awk适合格式化文本，对文本进程复杂的处理
  grep [-acinv] [—color=auto] ‘re’ filename
    -a将
    -c计算匹配的次数
    忽略大小写
输出行号
反向选择即显示出不匹配的一行
—color=auto 关键字部分
 awk [-F fs] [-v var=value] [‘{prog}’ | -f progfile] [file …]
 fs分隔符,是一个字符串或者正则表达式，指定的是分割各项的字符。可使用多个分隔符 ‘[ ,]'表示先使用空格分隔。然后对分隔结果使用,分割
 赋值一个用户定义变量
内置变量 
NR 行号
NF 当前行的字段个数
从脚本文件中读取awk命令
prog中$1、$n表示第n项,$0表示完整的输入记录
var设置后可以使用在prog中
sed [-hnV] [-e command] [-f<script文件>] [文本文件]
以行为单位的处理数据
mac的sed有点问题 需要\后换行输入
-h或—help显示帮助
-n或—quiet或—silent仅显示只有被script处理后会被输出到结果中
-v 显示版本信息
-i 真的改变文件中的内容，别的都是改变显示
command的形式
[address[,address]] function[arguments]
其中address可以是$代表最后一行，或是一个数字代表行数,后面[1addr]表示单个地址，[2addr]表示[1addr,1addr]
Function有
[1addr]a 新增字串 
[2addr]c 取代n1,n2之间的行 为后跟的子串
[2addr]d 删除n1,n2之间的行
[1addr]i 从目前的一行插入后跟的文本
[2addr]p 将数据输出
[2addr]s/regularexpression/replacement/flags
  取代工作
ipcs和ipcrm命令
IPC命令，IPC即为进程间通信
ipcs可以查看共享内存、信号量、消息队列的状态
-a 显示所有的IPC设施
-q/-s显示所有的信号量、共享内存
ipcrm 手动清除指定的共享内存、消息队列、信号量
-M shmkey / -m shmid / -S semkey / -s semid / -Q msgkey / -msgid
清除用xxkey/id创建/标识的共享内存/消息队列/信号量
nl命令
列出文件内容并标注行号
##查找当前目录以及字母下以.c结尾的文件，且文件中包含”hello world”的文件的路径
##创建定时任务
  crontab -e 编辑定时任务 crontab -l 查看定时任务
  格式为分时日月周命令
  当分为*时表示每分钟执行一次，时为*时表示每小时执行一次
##IO模型
五种IO模型：阻塞IO，非阻塞IO，IO复用，信号驱动式IO，异步IO
  阻塞IO： 数据够了才返回，此阶段进程一直阻塞
  非阻塞：读了就返回，不管有没有获取到数据就返回。
  IO复用：调用select或poll这样的，可以告知系统有数据准备好了，系统再去读取
  信号驱动IO：数据准备好时信号告知开始IO
  异步IO：通过aio_read，内核等数据准备好后，复制到用户空间中执行事先准备好的函数。此过程中，用户进程从未阻塞
##什么是粘包现象，如何避免粘包现象
  select，poll，epoll的区别
  select需要传fd_set，每次调用select都要遍历fd_set，开销比较大。并发数受fd_set的限制
  poll使用的是pollfd，不受fd_set的限制，其他一样
  epoll改进了前两个函数，epoll提供了三个函数，epoll_create（创建第一个epoll句柄）和epoll_ctl（注册要监听的事件类型）和epoll_wait（等待事件的发生），注册新的事件到epoll句柄中，会把所有的fd拷贝进内核，保证每个fd在整个过程中只会拷贝一次；epoll_ctl时把current挂一遍并未每个fd指定一个回调函数，当设备就绪，唤醒等待者时就会调用这个回调函数，这个回调函数就会把就绪的fd加入一个就绪链表。epoll_wait的实际工作就是查看有没有就绪的fd
线程池，内存池 自己动手实现一遍


#Linux的API
##fork与vfork区别 
  fork和vfork都用于创建子进程。但是vfork创建子进程后，父进程阻塞，直到子进程调用exit()或者excle()。 
对于内核中过程fork通过调用clone函数，然后clone函数调用do_fork()。do_fork()中调用copy_process()函数先复制task_struct结构体，然后复制其他关于内存，文件，寄存器等信息。fork采用写时拷贝技术，因此子进程和父进程的页表指向相同的页框。但是vfork不需要拷贝页表，因为父进程会一直阻塞，直接使用父进程页表。
##exit()与_exit()区别 
  exit()清理后进入内核，_exit()直接陷入内核。
##孤儿进程是怎么产生的？ 
  父进程先退出子进程还没退出，子进程将被托管给init进程，这里的子进程就是孤儿进程
##僵死进程是怎么产生的？ 
  子进程退出，而父进程没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，进程称之为僵死进程
##僵死进程的危害？
  大量的僵死进程会占用进程号，系统所能使用的进程号是有限的，将因为没有可用的进程号而导致不能产生新的进程
##如何避免僵死进程的产生？通过信号机制（退出时发个信号给父进程让父进程调用wait函数）
  fork两次 
  第一个调用fork产生一个子进程
  子进程调用fork函数在子进程中再产生个子进程，也就是孙进程
  子进程执行exit函数时使自己终止，孙进程就成了孤儿进程，利用init进程托管它就不会变成僵死进程
  调用waitpid函数去避免子进程变成僵死进程。
  孙进程需要先睡觉一段时间。要保证子进程先于孙进程退出
##Linux是如何避免内存碎片的
  伙伴算法，用于管理物理内存，避免内存碎片;
##高速缓存Slab层用于管理内核分配内存，避免碎片。
##共享内存的实现原理？
##系统调用与库函数(open, close, create, lseek, write, read)
##同步方法有哪些？
##互斥锁，自旋锁，信号量，读写锁，屏障
##互斥锁与自旋锁的区别：互斥锁得不到资源的时候阻塞，不占用cpu资源。自旋锁得不到资源的时候，不停的查询，而然占用cpu资源。
##死锁
  
